#' Simulate Incident and subsequent trait for independent SNPs
#'
#' This function allows you to simulate correlated incident and subsequent traits.
#' @param nsnps Number of SNPs to simulate
#' @param nind Number of individuals to simulate
#' @param h2_overall total of the incident and subsequent events
#' @param h2_incidentonly proportion of heritability
#'  affecting variance in outcome for incident event only
#' @param pd correlation between incident and subsequent event, 
#' default value is 0
#' @param cv confounder variance for incident and subsequent traits,
#' default value is 0.4
#' @param ev error variance for incident and subsequent traits, default is 0.1
#' @param minfreq minimum value for allele frequency to simulate according to HWE
#' default value is 0.01
#' @param maxfreq maximum value for allele frequency to simulate according to HWE
#' default value is 0.49
#' @param pi proportion of SNPs that contribute to incident, subsequent and
#'  both incident and subsequent traits, default value is 0.05 for all.
#' @keywords simulate, independent traits, correlated traits
#' @export
#' @examples
#' simul_independent(10000,20000,0.5,0.25)


simul_independent <- function(nsnps, nind, h2_overall,
                              h2_incidentonly,
                              pd=0, cv=0.4, ev=0.1,
                              minfreq=0.01, maxfreq=0.49, 
                              pi=c(0.05,0.05,0.05)) {

# simulate MAF for the individual SNPs between 0.01-0.49 
MAF <- runif(nsnps, min=minfreq, max=maxfreq)

# Simulate genotypes using the MAF for the individuals
# rows: nsnps, col: nind
gen_matrix <- t(sapply(MAF, function(p) rbinom(nind, size = 2, prob = p)))

# proportion of SNPS in each clusters (incident, subsequent, both, none)
pi1 <- pi[1]; pi2 <- pi[2]; pi3 <- pi[3]; pi4 <- 1- (pi1+pi2+pi3);

# Create confounder U that accounts cv variation
var.qtU <- cv
qtU <- rnorm(nind, sd=sqrt(var.qtU))

# SNP effect betas estimated using heritability beta = sqrt(h/ 2(MAF (1-MAF)))
# these are the values for the SNPs causal to incident and subsequent event only
#betaX <- sqrt((hx)/(2*MAF[c(1:(nsnps*pi1))]*(1-MAF[c(1:(nsnps*pi1))]))) 
#betaY <- sqrt((hy)/(2*MAF[c((nsnps*pi1+1):(nsnps*(pi1+pi2)))]*(1-MAF[c((nsnps*pi1+1):(nsnps*(pi1+pi2)))]))) 

#betaXY <- sqrt((hxy)/(2*MAF[c((nsnps*(pi1+pi2)+1):(nsnps*(pi1+pi2+pi3)))]
#                          *(1-MAF[c((nsnps*(pi1+pi2)+1):(nsnps*(pi1+pi2+pi3)))]))) 
betaX <- rnorm(nsnps*pi1, sd = sqrt(h2_overall*h2_incidentonly/(nsnps*pi1)))
betaY <- rnorm(nsnps*pi2, sd = sqrt(h2_overall*h2_incidentonly/(nsnps*pi2)))
# Generating correlated effect estimates betas for both X and Y:
# causal overlap between shared SNPs causes the genetic correlation
# number of shared SNPs = (nsnps*pi3), and we know:
# corr_g = cov(X,Y)/ [sqrt(VAR(X))*sqrt(VAR(Y))]
# Using heritability as trait variances for X and Y 
# we get that for each SNP SNP cov(X,Y) = corr_g * ((h-h_x)/(nsnps*pi3))
cor.betasxy <- (1/(nsnps*pi3))*as.matrix(rbind(c(h2_overall,h2_overall*pd),c(h2_overall*pd,h2_overall)))
base.betasxy <- mvtnorm::rmvnorm((nsnps*pi3),sigma=cor.betasxy)

#Create "true" betas for all SNPs from the causal effects 
Xbetas <- c(betaX,rep(0,nsnps*pi2),base.betasxy[,1],rep(0, nsnps*pi4))
Ybetas <- c(rep(0,nsnps*pi1),betaY,base.betasxy[,2],rep(0, nsnps*pi4))

# create quantitative trait X (incidence) for each individual
# X = \beta_GX G + \beta_XU U + Ex
Xval <- t(gen_matrix)%*%(Xbetas)
Xva<-var(Xval)

qtX <-Xval + qtU + stats::rnorm(nind,sd=(ev)^.5)
qtX<-qtX-mean(qtX)
# Estimating Heritability of incident event trait
#hxhat<-Xva/var(qtX) 

# Create quantitative trait for Y 
# Y = \beta_GY G + \beta_YU U + \beta_XY X + E_y
# beta_XY is effect of incidence on subsequent event
bxy <- 0 #following dudbridge

Yval <- t(gen_matrix)%*%(Ybetas)
Yva<-var(Yval)
qtY <- Yval + qtU  + bxy * qtX + stats::rnorm(nind,sd=(ev)^.5)
qtY<-qtY-mean(qtY)
# Estimating Heritability of Subsequent event trait
#hyhat<-Yva/var(qtY) #h2

return(list(incident_trait = qtX, subsequent_trait = qtY,
            genotype_matrix = gen_matrix))
}

#' Simulate Incident and subsequent trait for LD correlated SNPs
#'
#' This function allows you to simulate correlated incident and subsequent traits.
#' @param gpath path of the .gen file generated by hapgen
#' @param h2_overall total of the incident and subsequent events
#' @param h2_incidentonly proportion of heritability
#'  affecting variance in outcome for incident event only
#' @param pd correlation between incident and subsequent event, 
#' default value is 0
#' @param cv confounder variance for incident and subsequent traits,
#' default value is 0.4
#' @param ev error variance for incident and subsequent traits, default is 0.1
#' @param minfreq minimum value for allele frequency to simulate according to HWE
#' default value is 0.01
#' @param maxfreq maximum value for allele frequency to simulate according to HWE
#' default value is 0.49
#' @param pi proportion of SNPs that contribute to incident, subsequent and
#'  both incident and subsequent traits, default value is 0.05 for all.
#' @keywords simulate, traits with LD, correlated traits
#' @export
#' @examples
#' simul_withld("chr19.hapgen_simul",0.5,0.25)

simul_withld <- function (gpath, nind, h2_overall,
          h2_incidentonly,
          pd=0, cv=0.4, ev=0.1,
          minfreq=0.01, maxfreq=0.49, 
          pi=c(0.05,0.05,0.05)) {
  
  # read in the oxgen file generated from hapgen
  gen_data <- data.table::fread(paste(gpath,".gen", sep=""), header = FALSE)
  id_snps <- gen_data$V2
  
  # Extract genotype probability columns (from 6th onward)
  gen_probs <- as.matrix(gen_data[, 6:ncol(gen_data)])
  # write a C++ function to do the genotype calculation
  Rcpp::cppFunction('
NumericMatrix geno_create(NumericMatrix probs) {
  int n_snps = probs.nrow();
  int n_probs = probs.ncol();
  int n_inds = n_probs / 3;
  
  NumericMatrix geno(n_snps, n_inds);
  
  for (int i = 0; i < n_snps; i++) {
    for (int j = 0; j < n_inds; j++) {
      double p0 = probs(i, j * 3);       
      double p1 = probs(i, j * 3 + 1);   
      double p2 = probs(i, j * 3 + 2); 
      geno(i, j) = p1 + 2.0 * p2;
    }
  }
  return geno;
}
')
  
  # use the cpp function
  gen_matrix2 <- geno_create(gen_probs)
  
  # C++ function to remove mulatiallelic SNPs, 
  # returns updated genotype matrix and row of indices for SNPs that are not removed
  Rcpp::cppFunction('
List remove_multiallelic(NumericMatrix geno) {
  int n_snps = geno.nrow();
  int n_id = geno.ncol();
  std::vector<int> index;
  
  for (int i = 0; i < n_snps; i ++) {
    bool multiallelic = true;
    int first_value = geno(i, 0);
    for (int j = 0; j < n_id; j++) {
    	if (geno(i, j) != first_value) {
	 multiallelic = false;
	 break;
 	}
    }	
    if (!multiallelic) {
      index.push_back(i);
    }
  }

  int new_nsnps = index.size();
  NumericMatrix result(new_nsnps, n_id);
  IntegerVector indices(new_nsnps);

  for (int i = 0; i < new_nsnps; i++) {
    indices[i] = index[i] + 1;  // Convert to 1-based index for R
    for (int j = 0; j < n_id; j++) {
      result(i, j) = geno(index[i], j);
    }
  }

   return List::create(Named("filtered_matrix") = result,
    Named("kept_indices") = indices
  );

}
')
  # create updated matrix removing multiallelic matrices
  geno_removed <- remove_multiallelic(gen_matrix2)
  gen_matrix <- geno_removed$filtered_matrix
  # get number of individuals simulated
  nind <- ncol(gen_matrix)
  # retain SNP ID and position
  row_gen <- id_snps[geno_removed$kept_indices]
  snp_pos <- gen_data$V3[geno_removed$kept_indices]
  id_sample <- paste("id_",c(1:nind),sep="")
  colnames(gen_matrix) <- id_sample
  rownames(gen_matrix) <- row_gen
  
  # proportion of SNPS in each clusters (incident, subsequent, both, none)
  pi1 <- pi[1]; pi2 <- pi[2]; pi3 <- pi[3]; pi4 <- 1- (pi1+pi2+pi3);
  nsnps <- length(row_gen)
  # Create confounder U that accounts cv variation
  var.qtU <- cv
  qtU <- rnorm(nind, sd=sqrt(var.qtU))
  
  # for the 10000 SNPs hapgen file: 5968, 
  # for the 20000 SNPs hapgen file: 13145
  # getting a list of causal snps and diving them into causal for incident, subsequent and both
  inc_causal <- ceiling(pi1*nsnps)
  sub_causal <- ceiling(pi2*nsnps)
  both_causal <- ceiling(pi3*nsnps)
  causalSNPs_n <- inc_causal + sub_causal + both_causal
  # Get a set of random causal SNPs using PhenotypeSimulator
  causal <- PhenotypeSimulator::getCausalSNPs(N=nind,NrCausalSNPs=causalSNPs_n,genotypes=t(gen_matrix))
  # Separating the SNP genotypes for incident, subsequent snps
  incident_causalSNPs <- causal[,1:inc_causal]
  subsequent_causalSNPs <- causal[,(inc_causal+1):(inc_causal+sub_causal)]
  both_causalSNPs <- causal[,(sub_causal + inc_causal+1):causalSNPs_n]
  # SNP effect betas estimated using heritability beta = sqrt(h/ 2(MAF (1-MAF)))
  # these are the values for the SNPs causal to incident and subsequent event only
  betaX <- rnorm(inc_causal, sd = sqrt(h2_overall*h2_incidentonly/(inc_causal)))
  betaY <- rnorm(sub_causal, sd = sqrt(h2_overall*h2_incidentonly/(sub_causal)))
  
  # Generating correlated effect estimates betas for both X and Y:
  # causal overlap between shared SNPs causes the genetic correlation
  # number of shared SNPs = (nsnps*pi3), and we know:
  # corr_g = cov(X,Y)/ [sqrt(VAR(X))*sqrt(VAR(Y))]
  # Using heritability as trait variances for X and Y 
  cor.betasxy <- (1/(both_causal))*as.matrix(rbind(c(h2_overall,h2_overall*pd),
                                                   c(h2_overall*pd,h2_overall)))
  base.betasxy <- rmvnorm((both_causal),sigma=cor.betasxy)
  # Setting values for incident event 
  Xbetas <- data.frame(rep(0,nsnps))
  rownames(Xbetas) <- row_gen
  colnames(Xbetas) <- c("BETA")
  Xbetas[colnames(incident_causalSNPs)] <- betaX
  Xbetas[colnames(both_causalSNPs),] <- base.betasxy[,1]
  
  # Setting values for subsequent event 
  Ybetas <- data.frame(rep(0,nsnps))
  rownames(Ybetas) <- row_gen
  colnames(Ybetas) <- c("BETA")
  Ybetas[colnames(subsequent_causalSNPs),] <- betaY
  Ybetas[colnames(both_causalSNPs),] <- base.betasxy[,2]
  
  # TEST function from PhenotypeSimulator
  #effect <- geneticFixedEffects(X_causal=causal,P=2,N=1000,pTraitsAffected=1,pIndependentGenetic=0.25,distBeta="norm", mBeta=0, sdBeta=((0.5*0.25)/100))
  
  
  # create quantitative trait X (incidence) for each individual
  # X = \beta_GX G + \beta_XU U + Ex
  Xval <- t(gen_matrix) %*% c(Xbetas$BETA)
  Xva<-var(Xval)
  
  qtX <-Xval + qtU + stats::rnorm(nind,sd=(ev)^.5)
  qtX<-qtX-mean(qtX)
  
  # Estimating Heritability of incident event trait
  #hxhat<-Xva/var(qtX) 
  
  # Create quantitative trait for Y 
  # Y = \beta_GY G + \beta_YU U + \beta_XY X + E_y
  # beta_XY is effect of incidence on subsequent event
  bxy <- 0 # Following Dudbridge (2019)
  
  Yval <- t(gen_matrix)%*%c(Ybetas$BETA)
  Yva<-var(Yval)
  qtY <- Yval + qtU  + bxy * qtX + stats::rnorm(nind,sd=(ev)^.5)
  qtY<-qtY-mean(qtY)
  # Estimating Heritability of Subsequent event trait
  #hyhat<-Yva/var(qtY) #h2
  return(list(incident_trait = qtX, subsequent_trait = qtY,
              genotype_matrix = gen_matrix))
}