install.packages("clustra")
library(clustra)
repo = "https://github.com/MVP-CHAMPION/"
repo_sas = paste0(repo, "clustra-SAS/raw/main/")
if(full_data) {
url = paste0(repo_sas, "bp_data/simulated_data_27June2023.csv.gz")
data = data.table::fread(url)
} else {
data = bp10k
}
knitr::opts_knit$set(
collapse = TRUE,
comment = "#>"
)
cran = list(LibsData = TRUE, plot_true = TRUE, plot_raw = TRUE, run5 = TRUE, run5_v2 = FALSE, iter_plots = TRUE, plot5_side_by_side = FALSE, fig1 = FALSE, comp_true = FALSE, run10 = FALSE, plot10 = FALSE, run2 = FALSE, rand2 = FALSE, silplot = FALSE, silplot2 = FALSE, rand_plot = FALSE, hclust40 = FALSE, SAS_R_data = FALSE, Rand_SAS_R = FALSE, true_group = FALSE)
figs = list(LibsData = TRUE, plot_true = FALSE, plot_raw = FALSE, run5 = TRUE, run5_v2 = TRUE, iter_plots = FALSE, plot5_side_by_side = FALSE, fig1 = TRUE, comp_true = TRUE, run10 = TRUE, plot10 = TRUE, run2 = TRUE, rand2 = TRUE, silplot = TRUE, silplot2 = FALSE, rand_plot = TRUE, hclust40 = FALSE, SAS_R_data = TRUE, Rand_SAS_R = TRUE, true_group = TRUE)
all = list(LibsData = TRUE, plot_true = TRUE, plot_raw = TRUE, run5 = TRUE, run5_v2 = TRUE, iter_plots = TRUE, plot5_side_by_side = TRUE, fig1 = TRUE, comp_true = TRUE, run10 = TRUE, plot10 = TRUE, run2 = TRUE, rand2 = TRUE, silplot = TRUE, silplot2 = TRUE, rand_plot = TRUE, hclust40 = TRUE, SAS_R_data = TRUE, Rand_SAS_R = TRUE, true_group = TRUE)
chunk = cran  # chose which version of the vignette to run
full_data = FALSE # choose if full 80,000 id data or sample of 10,000 ids
mc = 2
# If running on a Unix or a Mac platform, set to number of available cores.
# This vignette will experience notable speedup up to about 10 cores.
# On Intel chips with hyperthreading, up to 2x available cores can be used.
if (.Platform$OS.type == "windows") mc = 1
data.table::setDTthreads(1) # manage data.table threads (increase with full_data)
repo = "https://github.com/MVP-CHAMPION/"
repo_sas = paste0(repo, "clustra-SAS/raw/main/")
if(full_data) {
url = paste0(repo_sas, "bp_data/simulated_data_27June2023.csv.gz")
data = data.table::fread(url)
} else {
data = bp10k
}
data$true_group = data$group
head(data)
View(data)
set.seed(12345)
plot_sample(data, layout = c(3, 3), group = "true_group")
plot_smooths(data, fits = NULL, max.data = 20000, group = "true_group")
set.seed(12345)
cl5 = clustra(data, k = 5, maxdf = 30, conv = c(20, 0.5), mccores = mc, verbose = TRUE)
clustra(data, k = 5, maxdf = 30, conv = c(10, 0.5), mccores = mc, verbose = 2, ylim = c(110, 170))
plot_smooths(data, fits = cl5$tps, max.data = 30000)
install.packages("devtools")
library("devtools")
devtools::install_github("klutometis/roxygen")
library(roxygen2)
getwd()
setwd("G:/Other computers/My Computer/VA Research/Dissertation/r_SCRIPTS/simulation_package")
getwd()
create("simul_trait")
create("simulateTrait")
ls
T || F
rnorm
library(mvtnorm)
library(dplyr)
# OPTIONAL: Number of SNPS and individuals (for testing)
nsnps <- 10000
nind <- 20000
h <- 0.5
h_x <- 0.25
out <- "hx5pd0"
pd <- 0
# Confounder variance
cv <- 0.4
#error variance
ev <- 1 - h - cv
# simulate MAF for the individual SNPs between 0.01-0.49
MAF <- runif(nsnps, min=0.01, max=0.49)
# Simulate genotypes using the MAF for the individuals
gen_matrix <- t(sapply(MAF, function(p) rbinom(nind, size = 2, prob = p)))
dim(gen_matrix)
simul_independent <- function(nsnps, nind, h2_overall,
h2_incidentonly,
pd=0, cv=0.4, ev=0.1,
minfreq=0.01, maxfreq=0.49,
pi=c(0.05,0.05,0.05)) {
# simulate MAF for the individual SNPs between 0.01-0.49
MAF <- runif(nsnps, min=minfreq, max=maxfreq)
# Simulate genotypes using the MAF for the individuals
# rows: nsnps, col: nind
gen_matrix <- t(sapply(MAF, function(p) rbinom(nind, size = 2, prob = p)))
# proportion of SNPS in each clusters (incident, subsequent, both, none)
pi1 <- pi[1]; pi2 <- pi[2]; pi3 <- pi[3]; pi4 <- 1 - pi1 - pi2 - pi3;
# heritability of incidence and prognosis event
# Variances for single SNP(incident only), VAR = (heritability explained by SNP_incident) / (nsnps*pi1)
# Set heritability for each causal SNP for incident (hx), subsequent(hy) and both (hxy)
hx <- rep(h2_incidentonly/(nsnps*pi1), (nsnps*pi1))
hy <- rep(h2_incidentonly/(nsnps*pi2), (nsnps*pi2))
hxy <- rep((h2_overall-h2_incidentonly)/(nsnps*pi3), (nsnps*pi3))
# Create confounder U that accounts for all except 10% of remaining variation
var.qtU <- cv
qtU <- rnorm(nind, sd=sqrt(var.qtU))
# SNP effect betas estimated using heritability beta = sqrt(h/ 2(MAF (1-MAF)))
# these are the values for the SNPs causal to incident and subsequent event only
#betaX <- sqrt((hx)/(2*MAF[c(1:(nsnps*pi1))]*(1-MAF[c(1:(nsnps*pi1))])))
#betaY <- sqrt((hy)/(2*MAF[c((nsnps*pi1+1):(nsnps*(pi1+pi2)))]*(1-MAF[c((nsnps*pi1+1):(nsnps*(pi1+pi2)))])))
#betaXY <- sqrt((hxy)/(2*MAF[c((nsnps*(pi1+pi2)+1):(nsnps*(pi1+pi2+pi3)))]
#                          *(1-MAF[c((nsnps*(pi1+pi2)+1):(nsnps*(pi1+pi2+pi3)))])))
betaX <- rnorm(nsnps*pi1, sd = sqrt(h*h_x/(nsnps*pi1)))
betaY <- rnorm(nsnps*pi2, sd = sqrt(h*h_x/(nsnps*pi2)))
# Generating correlated effect estimates betas for both X and Y:
# causal overlap between shared SNPs causes the genetic correlation
# number of shared SNPs = (nsnps*pi3), and we know:
# corr_g = cov(X,Y)/ [sqrt(VAR(X))*sqrt(VAR(Y))]
# Using heritability as trait variances for X and Y
# we get that for each SNP SNP cov(X,Y) = corr_g * ((h-h_x)/(nsnps*pi3))
cor.betasxy <- (1/(nsnps*pi3))*as.matrix(rbind(c(h,h*pd),c(h*pd,h)))
base.betasxy <- rmvnorm((nsnps*pi3),sigma=cor.betasxy)
#Create "true" betas for all SNPs from the causal effects
Xbetas <- c(betaX,rep(0,nsnps*pi2),base.betasxy[,1],rep(0, nsnps*pi4))
Ybetas <- c(rep(0,nsnps*pi1),betaY,base.betasxy[,2],rep(0, nsnps*pi4))
# create quantitative trait X (incidence) for each individual
# X = \beta_GX G + \beta_XU U + Ex
Xval <- t(gen_matrix)%*%(Xbetas)
Xva<-var(Xval)
qtX <-Xval + qtU + stats::rnorm(nind,sd=(ev)^.5)
qtX<-qtX-mean(qtX)
# Estimating Heritability of incident event trait
#hxhat<-Xva/var(qtX)
# Create quantitative trait for Y
# Y = \beta_GY G + \beta_YU U + \beta_XY X + E_y
# beta_XY is effect of incidence on subsequent event
bxy <- 0 #following dudbridge
Yval <- t(gen_matrix)%*%(Ybetas)
Yva<-var(Yval)
qtY <- Yval + qtU  + bxy * qtX + stats::rnorm(nind,sd=(ev)^.5)
qtY<-qtY-mean(qtY)
# Estimating Heritability of Subsequent event trait
#hyhat<-Yva/var(qtY) #h2
return(list(incident_trait = qtX, subsequent_trait = qtY,
genotype_matrix = gen_matrix))
}
simul1 <- simul_independent(10000,20000,0.5,0.25)
# proportion of SNPS in each clusters (incident, subsequent, both, none)
pi1 <- 0.05; pi2 <- 0.05; pi3 <- 0.05; pi4 <- 0.85
# p-value threshold for methods
thresh <- 0.01
# heritability of incidence and prognosis event
# Variances for single SNP(incident only), VAR = (heritability explained by SNP_incident) / (nsnps*pi1)
# Set heritability for each causal SNP for incident (hx), subsequent(hy) and both (hxy)
hx <- rep(h_x/(nsnps*pi1), (nsnps*pi1))
hy <- rep(h_x/(nsnps*pi2), (nsnps*pi2))
hxy <- rep((h-h_x)/(nsnps*pi3), (nsnps*pi3))
# Create confounder U that accounts for all except 10% of remaining variation
var.qtU <- cv
qtU <- rnorm(nind, sd=sqrt(var.qtU))
# SNP effect betas estimated using heritability beta = sqrt(h/ 2(MAF (1-MAF)))
# these are the values for the SNPs causal to incident and subsequent event only
#betaX <- sqrt((hx)/(2*MAF[c(1:(nsnps*pi1))]*(1-MAF[c(1:(nsnps*pi1))])))
#betaY <- sqrt((hy)/(2*MAF[c((nsnps*pi1+1):(nsnps*(pi1+pi2)))]*(1-MAF[c((nsnps*pi1+1):(nsnps*(pi1+pi2)))])))
#betaXY <- sqrt((hxy)/(2*MAF[c((nsnps*(pi1+pi2)+1):(nsnps*(pi1+pi2+pi3)))]
#                          *(1-MAF[c((nsnps*(pi1+pi2)+1):(nsnps*(pi1+pi2+pi3)))])))
betaX <- rnorm(nsnps*pi1, sd = sqrt(h*h_x/(nsnps*pi1)))
betaY <- rnorm(nsnps*pi2, sd = sqrt(h*h_x/(nsnps*pi2)))
#cor.betasxy <- (1/(nsnps*pi3))*as.matrix(rbind(c((h-h_x),(h-h_x)*pd),c((h-h_x)*pd,(h-h_x))))
cor.betasxy <- (1/(nsnps*pi3))*as.matrix(rbind(c(h,h*pd),c(h*pd,h)))
base.betasxy <- rmvnorm((nsnps*pi3),sigma=cor.betasxy)
#Xbetas <- c(betaX,rep(0,nsnps*pi2),betaXY,rep(0, nsnps*pi4))
#Ybetas <- c(rep(0,nsnps*pi1),betaY,betaXY,rep(0, nsnps*pi4))
#Create "true" betas for all SNPs from the causal effects
Xbetas <- c(betaX,rep(0,nsnps*pi2),base.betasxy[,1],rep(0, nsnps*pi4))
Ybetas <- c(rep(0,nsnps*pi1),betaY,base.betasxy[,2],rep(0, nsnps*pi4))
# create quantitative trait X (incidence) for each individual
# X = \beta_GX G + \beta_XU U + Ex
Xval <- t(gen_matrix)%*%(Xbetas)
Xva<-var(Xval)
qtX <-Xval + qtU + stats::rnorm(nind,sd=(ev)^.5)
qtX<-qtX-mean(qtX)
# Estimating Heritability of incident event trait
hxhat<-Xva/var(qtX)
# Create quantitative trait for Y
# Y = \beta_GY G + \beta_YU U + \beta_XY X + E_y
# beta_XY is effect of incidence on subsequent event
bxy <- 0 #following dudbridge
Yval <- t(gen_matrix)%*%(Ybetas)
Yva<-var(Yval)
qtY <- Yval + qtU  + bxy * qtX + stats::rnorm(nind,sd=(ev)^.5)
qtY<-qtY-mean(qtY)
# Estimating Heritability of Subsequent event trait
hyhat<-Yva/var(qtY) #h2
rm(list = ls())
simul_independent <- function(nsnps, nind, h2_overall,
h2_incidentonly,
pd=0, cv=0.4, ev=0.1,
minfreq=0.01, maxfreq=0.49,
pi=c(0.05,0.05,0.05)) {
# simulate MAF for the individual SNPs between 0.01-0.49
MAF <- runif(nsnps, min=minfreq, max=maxfreq)
# Simulate genotypes using the MAF for the individuals
# rows: nsnps, col: nind
gen_matrix <- t(sapply(MAF, function(p) rbinom(nind, size = 2, prob = p)))
# proportion of SNPS in each clusters (incident, subsequent, both, none)
pi1 <- pi[1]; pi2 <- pi[2]; pi3 <- pi[3]; pi4 <- 1 - pi1 - pi2 - pi3;
# heritability of incidence and prognosis event
# Variances for single SNP(incident only), VAR = (heritability explained by SNP_incident) / (nsnps*pi1)
# Set heritability for each causal SNP for incident (hx), subsequent(hy) and both (hxy)
hx <- rep(h2_incidentonly/(nsnps*pi1), (nsnps*pi1))
hy <- rep(h2_incidentonly/(nsnps*pi2), (nsnps*pi2))
hxy <- rep((h2_overall-h2_incidentonly)/(nsnps*pi3), (nsnps*pi3))
# Create confounder U that accounts for all except 10% of remaining variation
var.qtU <- cv
qtU <- rnorm(nind, sd=sqrt(var.qtU))
# SNP effect betas estimated using heritability beta = sqrt(h/ 2(MAF (1-MAF)))
# these are the values for the SNPs causal to incident and subsequent event only
#betaX <- sqrt((hx)/(2*MAF[c(1:(nsnps*pi1))]*(1-MAF[c(1:(nsnps*pi1))])))
#betaY <- sqrt((hy)/(2*MAF[c((nsnps*pi1+1):(nsnps*(pi1+pi2)))]*(1-MAF[c((nsnps*pi1+1):(nsnps*(pi1+pi2)))])))
#betaXY <- sqrt((hxy)/(2*MAF[c((nsnps*(pi1+pi2)+1):(nsnps*(pi1+pi2+pi3)))]
#                          *(1-MAF[c((nsnps*(pi1+pi2)+1):(nsnps*(pi1+pi2+pi3)))])))
betaX <- rnorm(nsnps*pi1, sd = sqrt(h2_overall*h2_incidentonly/(nsnps*pi1)))
betaY <- rnorm(nsnps*pi2, sd = sqrt(h2_overall*h2_incidentonly/(nsnps*pi2)))
# Generating correlated effect estimates betas for both X and Y:
# causal overlap between shared SNPs causes the genetic correlation
# number of shared SNPs = (nsnps*pi3), and we know:
# corr_g = cov(X,Y)/ [sqrt(VAR(X))*sqrt(VAR(Y))]
# Using heritability as trait variances for X and Y
# we get that for each SNP SNP cov(X,Y) = corr_g * ((h-h_x)/(nsnps*pi3))
cor.betasxy <- (1/(nsnps*pi3))*as.matrix(rbind(c(h2_overall,h2_overall*pd),c(h2_overall*pd,h2_overall)))
base.betasxy <- rmvnorm((nsnps*pi3),sigma=cor.betasxy)
#Create "true" betas for all SNPs from the causal effects
Xbetas <- c(betaX,rep(0,nsnps*pi2),base.betasxy[,1],rep(0, nsnps*pi4))
Ybetas <- c(rep(0,nsnps*pi1),betaY,base.betasxy[,2],rep(0, nsnps*pi4))
# create quantitative trait X (incidence) for each individual
# X = \beta_GX G + \beta_XU U + Ex
Xval <- t(gen_matrix)%*%(Xbetas)
Xva<-var(Xval)
qtX <-Xval + qtU + stats::rnorm(nind,sd=(ev)^.5)
qtX<-qtX-mean(qtX)
# Estimating Heritability of incident event trait
#hxhat<-Xva/var(qtX)
# Create quantitative trait for Y
# Y = \beta_GY G + \beta_YU U + \beta_XY X + E_y
# beta_XY is effect of incidence on subsequent event
bxy <- 0 #following dudbridge
Yval <- t(gen_matrix)%*%(Ybetas)
Yva<-var(Yval)
qtY <- Yval + qtU  + bxy * qtX + stats::rnorm(nind,sd=(ev)^.5)
qtY<-qtY-mean(qtY)
# Estimating Heritability of Subsequent event trait
#hyhat<-Yva/var(qtY) #h2
return(list(incident_trait = qtX, subsequent_trait = qtY,
genotype_matrix = gen_matrix))
}
simul1 <- simul_independent(10000,20000,0.5,0.25)
pi1
nsnps <- 10000
nind <- 20000
h <- 0.5
h_x <- 0.25
out <- "hx5pd0"
pd <- 0
# Confounder variance
cv <- 0.4
#error variance
ev <- 1 - h - cv
h2_overall <- 0.5
h2_incidentonly <- 0.25
minfreq=0.01
maxfreq = 0.49
pi=c(0.05,0.05,0.05)
MAF <- runif(nsnps, min=minfreq, max=maxfreq)
gen_matrix <- t(sapply(MAF, function(p) rbinom(nind, size = 2, prob = p)))
# proportion of SNPS in each clusters (incident, subsequent, both, none)
pi1 <- pi[1]; pi2 <- pi[2]; pi3 <- pi[3]; pi4 <- 1 - pi1 - pi2 - pi3;
# Create confounder U that accounts for all except 10% of remaining variation
var.qtU <- cv
qtU <- rnorm(nind, sd=sqrt(var.qtU))
betaX <- rnorm(nsnps*pi1, sd = sqrt(h2_overall*h2_incidentonly/(nsnps*pi1)))
betaY <- rnorm(nsnps*pi2, sd = sqrt(h2_overall*h2_incidentonly/(nsnps*pi2)))
cor.betasxy <- (1/(nsnps*pi3))*as.matrix(rbind(c(h2_overall,h2_overall*pd),c(h2_overall*pd,h2_overall)))
base.betasxy <- mvtnorm::rmvnorm((nsnps*pi3),sigma=cor.betasxy)
Xbetas <- c(betaX,rep(0,nsnps*pi2),base.betasxy[,1],rep(0, nsnps*pi4))
Ybetas <- c(rep(0,nsnps*pi1),betaY,base.betasxy[,2],rep(0, nsnps*pi4))
nsnps*pi1
nsnps*pi2
nsnps*pi3
nsnps*pi4
View(gen_matrix)
betaX <- rnorm(nsnps*pi1, sd = sqrt(h2_overall*h2_incidentonly/(nsnps*pi1)))
length(Xbetas)
length(base.betasxy[,1])
length(base.betasxy[,2])
rep(0,nsnps*pi2
)
length(rep(0,nsnps*pi2))
Xval <- t(gen_matrix)%*%(Xbetas)
#Create "true" betas for all SNPs from the causal effects
Xbetas <- c(betaX,rep(0,nsnps*pi2),base.betasxy[,1],rep(0, nsnps*pi4))
Ybetas <- c(rep(0,nsnps*pi1),betaY,base.betasxy[,2],rep(0, nsnps*pi4))
rm(list = ls())
nsnps <- 10000
nind <- 20000
h <- 0.5
h_x <- 0.25
out <- "hx5pd0"
pd <- 0
# Confounder variance
cv <- 0.4
#error variance
ev <- 1 - h - cv
# simulate MAF for the individual SNPs between 0.01-0.49
MAF <- runif(nsnps, min=0.01, max=0.49)
# Simulate genotypes using the MAF for the individuals
gen_matrix <- t(sapply(MAF, function(p) rbinom(nind, size = 2, prob = p)))
# proportion of SNPS in each clusters (incident, subsequent, both, none)
pi1 <- 0.05; pi2 <- 0.05; pi3 <- 0.05; pi4 <- 0.85
# p-value threshold for methods
thresh <- 0.01
# heritability of incidence and prognosis event
# Variances for single SNP(incident only), VAR = (heritability explained by SNP_incident) / (nsnps*pi1)
# Set heritability for each causal SNP for incident (hx), subsequent(hy) and both (hxy)
hx <- rep(h_x/(nsnps*pi1), (nsnps*pi1))
hy <- rep(h_x/(nsnps*pi2), (nsnps*pi2))
hxy <- rep((h-h_x)/(nsnps*pi3), (nsnps*pi3))
# Create confounder U that accounts for all except 10% of remaining variation
var.qtU <- cv
qtU <- rnorm(nind, sd=sqrt(var.qtU))
# SNP effect betas estimated using heritability beta = sqrt(h/ 2(MAF (1-MAF)))
# these are the values for the SNPs causal to incident and subsequent event only
#betaX <- sqrt((hx)/(2*MAF[c(1:(nsnps*pi1))]*(1-MAF[c(1:(nsnps*pi1))])))
#betaY <- sqrt((hy)/(2*MAF[c((nsnps*pi1+1):(nsnps*(pi1+pi2)))]*(1-MAF[c((nsnps*pi1+1):(nsnps*(pi1+pi2)))])))
#betaXY <- sqrt((hxy)/(2*MAF[c((nsnps*(pi1+pi2)+1):(nsnps*(pi1+pi2+pi3)))]
#                          *(1-MAF[c((nsnps*(pi1+pi2)+1):(nsnps*(pi1+pi2+pi3)))])))
betaX <- rnorm(nsnps*pi1, sd = sqrt(h*h_x/(nsnps*pi1)))
betaY <- rnorm(nsnps*pi2, sd = sqrt(h*h_x/(nsnps*pi2)))
# Generating correlated effect estimates betas for both X and Y:
# causal overlap between shared SNPs causes the genetic correlation
# number of shared SNPs = (nsnps*pi3), and we know:
# corr_g = cov(X,Y)/ [sqrt(VAR(X))*sqrt(VAR(Y))]
# Using heritability as trait variances for X and Y
# we get that for each SNP SNP cov(X,Y) = corr_g * ((h-h_x)/(nsnps*pi3))
#cor.betasxy <- (1/(nsnps*pi3))*as.matrix(rbind(c((h-h_x),(h-h_x)*pd),c((h-h_x)*pd,(h-h_x))))
cor.betasxy <- (1/(nsnps*pi3))*as.matrix(rbind(c(h,h*pd),c(h*pd,h)))
base.betasxy <- rmvnorm((nsnps*pi3),sigma=cor.betasxy)
#Xbetas <- c(betaX,rep(0,nsnps*pi2),betaXY,rep(0, nsnps*pi4))
#Ybetas <- c(rep(0,nsnps*pi1),betaY,betaXY,rep(0, nsnps*pi4))
#Create "true" betas for all SNPs from the causal effects
Xbetas <- c(betaX,rep(0,nsnps*pi2),base.betasxy[,1],rep(0, nsnps*pi4))
Ybetas <- c(rep(0,nsnps*pi1),betaY,base.betasxy[,2],rep(0, nsnps*pi4))
h2_overall = 0.5
h2_incidentonly = 0.25
gen_matrix <- t(sapply(MAF, function(p) rbinom(nind, size = 2, prob = p)))
pi=c(0.05,0.05,0.05)
pi1 <- pi[1]; pi2 <- pi[2]; pi3 <- pi[3]; pi4 <- 1 - pi1 - pi2 - pi3;
# Create confounder U that accounts cv variation
var.qtU <- cv
qtU <- rnorm(nind, sd=sqrt(var.qtU))
betaX <- rnorm(nsnps*pi1, sd = sqrt(h2_overall*h2_incidentonly/(nsnps*pi1)))
betaY <- rnorm(nsnps*pi2, sd = sqrt(h2_overall*h2_incidentonly/(nsnps*pi2)))
cor.betasxy <- (1/(nsnps*pi3))*as.matrix(rbind(c(h2_overall,h2_overall*pd),c(h2_overall*pd,h2_overall)))
base.betasxy <- mvtnorm::rmvnorm((nsnps*pi3),sigma=cor.betasxy)
Xbetas <- c(betaX,rep(0,nsnps*pi2),base.betasxy[,1],rep(0, nsnps*pi4))
Ybetas <- c(rep(0,nsnps*pi1),betaY,base.betasxy[,2],rep(0, nsnps*pi4))
length(betaX)
nsnps*pi4
length(base.betasxy[,1])
Xbetas <- c(betaX,base.betasxy[,1],rep(0, nsnps*pi4))
Xbetas <- c(betaX,rep(0,nsnps*pi2),rep(0, nsnps*pi4))
Xbetas <- c(betaX,rep(0,nsnps*pi2),base.betasxy[,1])
nsnps*pi4
length(0,nsnps*pi4)
length(rep(0,nsnps*pi4))
length(rep(0,nsnps*pi2))
nsnps*pi2
length(rep(0,9000))
length(rep(0,8500))
length(rep(0,nsnps))
length(rep(0,pi4*nsnps))
pi=c(0.05,0.05,0.05, 0.85)
# proportion of SNPS in each clusters (incident, subsequent, both, none)
pi1 <- pi[1]; pi2 <- pi[2]; pi3 <- pi[3]; pi4 <- pi[4];
# Create confounder U that accounts cv variation
var.qtU <- cv
qtU <- rnorm(nind, sd=sqrt(var.qtU))
# SNP effect betas estimated using heritability beta = sqrt(h/ 2(MAF (1-MAF)))
# these are the values for the SNPs causal to incident and subsequent event only
#betaX <- sqrt((hx)/(2*MAF[c(1:(nsnps*pi1))]*(1-MAF[c(1:(nsnps*pi1))])))
#betaY <- sqrt((hy)/(2*MAF[c((nsnps*pi1+1):(nsnps*(pi1+pi2)))]*(1-MAF[c((nsnps*pi1+1):(nsnps*(pi1+pi2)))])))
#betaXY <- sqrt((hxy)/(2*MAF[c((nsnps*(pi1+pi2)+1):(nsnps*(pi1+pi2+pi3)))]
#                          *(1-MAF[c((nsnps*(pi1+pi2)+1):(nsnps*(pi1+pi2+pi3)))])))
betaX <- rnorm(nsnps*pi1, sd = sqrt(h2_overall*h2_incidentonly/(nsnps*pi1)))
betaY <- rnorm(nsnps*pi2, sd = sqrt(h2_overall*h2_incidentonly/(nsnps*pi2)))
# Generating correlated effect estimates betas for both X and Y:
# causal overlap between shared SNPs causes the genetic correlation
# number of shared SNPs = (nsnps*pi3), and we know:
# corr_g = cov(X,Y)/ [sqrt(VAR(X))*sqrt(VAR(Y))]
# Using heritability as trait variances for X and Y
# we get that for each SNP SNP cov(X,Y) = corr_g * ((h-h_x)/(nsnps*pi3))
cor.betasxy <- (1/(nsnps*pi3))*as.matrix(rbind(c(h2_overall,h2_overall*pd),c(h2_overall*pd,h2_overall)))
base.betasxy <- mvtnorm::rmvnorm((nsnps*pi3),sigma=cor.betasxy)
#Create "true" betas for all SNPs from the causal effects
Xbetas <- c(betaX,rep(0,nsnps*pi2),base.betasxy[,1],rep(0, nsnps*pi4))
Ybetas <- c(rep(0,nsnps*pi1),betaY,base.betasxy[,2],rep(0, nsnps*pi4))
length(rep(0,pi4*nsnps))
pi_i <- 0.85
a <- 10000
length(rep(0,pi_i * a))
pi_i <- 1 - 0.05 -0.05-0.05
length(rep(0,pi_i * a))
pi_i <- 1 - 0.15
length(rep(0,pi_i * a))
pi_i <- 1 - 0.05 - 0.10
length(rep(0,pi_i * a))
pi_i <- 1 - 0.05 - 0.05 - 0.05
length(rep(0,pi_i * a))
pi_i <- 0.85
a <- 100
length(rep(0,pi_i * a))
pi_2 <- 1 - 0.05 - 0.05 - 0.05
length(rep(0,pi_2 * a))
pi_2
pi_i
pi_2 <- 1 - (0.05 + 0.05 + 0.05)
length(rep(0,pi_2 * a))
pi_2 <- 1 - 0.05 - 0.05 - 0.05
length(rep(0,pi_2 * a))
length(rep(0,times=pi_2 * a))
version
p <- 1 - 0.05 - 0.05 - 0.05
length(rep(0,times=p * a))
p <- 0.85
a <- 100
length(rep(0,p*a))
p <- 1 - 0.05 - 0.05 - 0.05
length(rep(0,p*a))
length(rep(0,int(p*a)))
length(rep(0,as.numeric(p*a)))
length(rep(0,as.integer(p*a)))
p
length(rep(0,ceiling(p*a)))
p <- 1 - 0.05 - 0.05 - 0.15
p
length(rep(0,as.numeric(p*a)))
length(rep(0,ceiling(p*a)))
simul_independent <- function(nsnps, nind, h2_overall,
h2_incidentonly,
pd=0, cv=0.4, ev=0.1,
minfreq=0.01, maxfreq=0.49,
pi=c(0.05,0.05,0.05)) {
# simulate MAF for the individual SNPs between 0.01-0.49
MAF <- runif(nsnps, min=minfreq, max=maxfreq)
# Simulate genotypes using the MAF for the individuals
# rows: nsnps, col: nind
gen_matrix <- t(sapply(MAF, function(p) rbinom(nind, size = 2, prob = p)))
# proportion of SNPS in each clusters (incident, subsequent, both, none)
pi1 <- pi[1]; pi2 <- pi[2]; pi3 <- pi[3]; pi4 <- 1- (pi1+pi2+pi3);
# Create confounder U that accounts cv variation
var.qtU <- cv
qtU <- rnorm(nind, sd=sqrt(var.qtU))
# SNP effect betas estimated using heritability beta = sqrt(h/ 2(MAF (1-MAF)))
# these are the values for the SNPs causal to incident and subsequent event only
#betaX <- sqrt((hx)/(2*MAF[c(1:(nsnps*pi1))]*(1-MAF[c(1:(nsnps*pi1))])))
#betaY <- sqrt((hy)/(2*MAF[c((nsnps*pi1+1):(nsnps*(pi1+pi2)))]*(1-MAF[c((nsnps*pi1+1):(nsnps*(pi1+pi2)))])))
#betaXY <- sqrt((hxy)/(2*MAF[c((nsnps*(pi1+pi2)+1):(nsnps*(pi1+pi2+pi3)))]
#                          *(1-MAF[c((nsnps*(pi1+pi2)+1):(nsnps*(pi1+pi2+pi3)))])))
betaX <- rnorm(nsnps*pi1, sd = sqrt(h2_overall*h2_incidentonly/(nsnps*pi1)))
betaY <- rnorm(nsnps*pi2, sd = sqrt(h2_overall*h2_incidentonly/(nsnps*pi2)))
# Generating correlated effect estimates betas for both X and Y:
# causal overlap between shared SNPs causes the genetic correlation
# number of shared SNPs = (nsnps*pi3), and we know:
# corr_g = cov(X,Y)/ [sqrt(VAR(X))*sqrt(VAR(Y))]
# Using heritability as trait variances for X and Y
# we get that for each SNP SNP cov(X,Y) = corr_g * ((h-h_x)/(nsnps*pi3))
cor.betasxy <- (1/(nsnps*pi3))*as.matrix(rbind(c(h2_overall,h2_overall*pd),c(h2_overall*pd,h2_overall)))
base.betasxy <- mvtnorm::rmvnorm((nsnps*pi3),sigma=cor.betasxy)
#Create "true" betas for all SNPs from the causal effects
Xbetas <- c(betaX,rep(0,nsnps*pi2),base.betasxy[,1],rep(0, nsnps*pi4))
Ybetas <- c(rep(0,nsnps*pi1),betaY,base.betasxy[,2],rep(0, nsnps*pi4))
# create quantitative trait X (incidence) for each individual
# X = \beta_GX G + \beta_XU U + Ex
Xval <- t(gen_matrix)%*%(Xbetas)
Xva<-var(Xval)
qtX <-Xval + qtU + stats::rnorm(nind,sd=(ev)^.5)
qtX<-qtX-mean(qtX)
# Estimating Heritability of incident event trait
#hxhat<-Xva/var(qtX)
# Create quantitative trait for Y
# Y = \beta_GY G + \beta_YU U + \beta_XY X + E_y
# beta_XY is effect of incidence on subsequent event
bxy <- 0 #following dudbridge
Yval <- t(gen_matrix)%*%(Ybetas)
Yva<-var(Yval)
qtY <- Yval + qtU  + bxy * qtX + stats::rnorm(nind,sd=(ev)^.5)
qtY<-qtY-mean(qtY)
# Estimating Heritability of Subsequent event trait
#hyhat<-Yva/var(qtY) #h2
return(list(incident_trait = qtX, subsequent_trait = qtY,
genotype_matrix = gen_matrix))
}
simul1 <- simul_independent(10000,20000,0.5,0.25)
getwd()
document()
ls
ls()
setwd(./simulateTrait)
setwd('./simulateTrait')
document()
document()
document()
document()
